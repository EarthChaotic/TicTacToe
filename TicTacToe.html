<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="layout.css" rel="stylesheet" type="text/css" />
    <title>Tic Tac Toe</title>
  </head>
  <body>
    <h1>Tic Tac Toe</h1>

    <label for="boardSize">Board Size: </label>

    <input type="number" id="boardSize" min="3" value="3" />

    <button onclick="startGame()">Start Game</button>

    <button onclick="resetGame()">Reset Game</button>

    <button onclick="replayGame()">Replay Game</button>

    <br />

    <label for="mode">Game Mode: </label>

    <!-- Select Mode -->
    <select class="textinput" id="mode" name="mode">
      <option selected value="PVP">Play with Your Friend</option>
      <option value="PVE">Play with AI (3x3 only)</option>
    </select>

    <div id="board">
      <!-- Dynamic Board -->
    </div>
  </body>
</html>
<script>
  let boardSize;
  let moves = [];
  let replayIndex = 0;
  let currentPlayer = "X";
  let Gamemode = document.getElementById("mode");
  const boardContainer = document.getElementById("board");
  const boardSizeInput = document.getElementById("boardSize");

  function startGame() {
    if (Gamemode.value === "PVE") {
      boardSize = 3; //AI Glitches So Set Max To 3
    } else {
      boardSize = parseInt(boardSizeInput.value);
    }

    currentPlayer = "X"; //Reset Player Every restart

    board = Array.from({ length: boardSize }, () =>
      Array.from({ length: boardSize }, () => "")
    );
    moves = []; // Clear the moves history for a new game
    renderBoard();

    if (Gamemode.value === "PVE") {
      matchHistory.push({
        moves: moves.slice(), // Clone the moves array
        winner: null, // The winner is not yet determined
      });
    }
  }

  function renderBoard() {
    boardContainer.innerHTML = "";
    boardContainer.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;

    for (let row = 0; row < boardSize; row++) {
      for (let col = 0; col < boardSize; col++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.row = row;
        cell.dataset.col = col;
        cell.addEventListener("click", makeMove);
        cell.textContent = board[row][col];
        boardContainer.appendChild(cell);
      }
    }
  }

  function resetGame() {
    // Reset the game board and currentPlayer
    board = Array.from({ length: boardSize }, () =>
      Array.from({ length: boardSize }, () => "")
    );
    currentPlayer = "X";

    // Clear the content of the cells on the game board
    const cells = boardContainer.querySelectorAll(".cell");
    cells.forEach((cell) => {
      cell.textContent = "";
    });
  }

  function makeMove(event) {
    const row = parseInt(event.target.dataset.row);
    const col = parseInt(event.target.dataset.col);

    if (board[row][col] === "" && !checkWin()) {
      board[row][col] = currentPlayer;
      event.target.textContent = currentPlayer;

      moves.push({ row, col, player: currentPlayer });

      if (checkWin()) {
        alert(currentPlayer + " wins!");
      } else if (checkDraw()) {
        alert("It's a draw!");
      } else {
        currentPlayer = currentPlayer === "X" ? "O" : "X";

        if (
          Gamemode.value === "PVE" &&
          currentPlayer === "O" &&
          !checkWin() &&
          !checkDraw()
        ) {
          const aiMove = bestMove();
          board[aiMove.i][aiMove.j] = currentPlayer;
          const aiCell = boardContainer.querySelector(
            `[data-row="${aiMove.i}"][data-col="${aiMove.j}"]`
          );
          aiCell.textContent = currentPlayer;

          moves.push({ row: aiMove.i, col: aiMove.j, player: currentPlayer }); // Store AI move

          if (checkWin()) {
            alert(currentPlayer + " wins!");
          } else if (checkDraw()) {
            alert("It's a draw!");
          }

          currentPlayer = "X";

          // Update the current match in the history with AI's move
          if (Gamemode.value === "PVE") {
            matchHistory[matchHistory.length - 1].moves = moves.slice();
            matchHistory[matchHistory.length - 1].winner = checkWin()
              ? "O"
              : null;
          }
        }
      }
    }
  }

  function checkWin() {
    // Check horizontal and vertical wins
    for (let i = 0; i < boardSize; i++) {
      let rowWin = true;
      let colWin = true;

      for (let j = 0; j < boardSize; j++) {
        if (board[i][j] !== currentPlayer) {
          rowWin = false;
        }
        if (board[j][i] !== currentPlayer) {
          colWin = false;
        }
      }

      if (rowWin || colWin) {
        return true;
      }
    }

    // Check diagonal wins
    let diag1Win = true;
    let diag2Win = true;

    for (let i = 0; i < boardSize; i++) {
      if (board[i][i] !== currentPlayer) {
        diag1Win = false;
      }
      if (board[i][boardSize - 1 - i] !== currentPlayer) {
        diag2Win = false;
      }
    }

    if (diag1Win || diag2Win) {
      return true;
    }

    return false;
  }

  function checkDraw() {
    for (let i = 0; i < boardSize; i++) {
      for (let j = 0; j < boardSize; j++) {
        if (board[i][j] === "") {
          return false;
        }
      }
    }
    return true;
  }

  function bestMove() {
    let bestScore = -Infinity;
    let move;

    for (let i = 0; i < boardSize; i++) {
      for (let j = 0; j < boardSize; j++) {
        if (board[i][j] === "") {
          board[i][j] = "O";
          let score = minimax(board, 0, false);
          board[i][j] = "";

          if (score > bestScore) {
            bestScore = score;
            move = { i, j };
          }
        }
      }
    }

    return move;
  }

  function minimax(board, depth, isMaximizing) {
    if (checkWin()) {
      return isMaximizing ? -10 : 10;
    } else if (checkDraw()) {
      return 0;
    }

    if (isMaximizing) {
      let bestScore = -Infinity;
      for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
          if (board[i][j] === "") {
            board[i][j] = "O";
            let score = minimax(board, depth + 1, false);
            board[i][j] = "";
            bestScore = Math.max(score, bestScore);
          }
        }
      }
      return bestScore;
    } else {
      let bestScore = Infinity;
      for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
          if (board[i][j] === "") {
            board[i][j] = "X";
            let score = minimax(board, depth + 1, true);
            board[i][j] = "";
            bestScore = Math.min(score, bestScore);
          }
        }
      }
      return bestScore;
    }
  }

  function replayMove() {
    if (replayIndex < moves.length) {
      const move = moves[replayIndex];
      const replayCell = boardContainer.querySelector(
        `[data-row="${move.row}"][data-col="${move.col}"]`
      );
      replayCell.textContent = move.player;
      replayIndex++;
    }
  }

  function replayGame() {
    resetGame();
    replayIndex = 0;
    const replayInterval = setInterval(() => {
      replayMove();
      if (replayIndex >= moves.length) {
        clearInterval(replayInterval);
      }
    }, 1000); // Replay interval in milliseconds (adjust as needed)
  }
</script>
